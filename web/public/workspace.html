<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>WorkSpace</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" integrity="sha512-c9fIxgR6+wUWp+dsr5pe0GWJMhF9ElVW9vDCtXQODp166tiEPc4DEqyRuPBU2VLcjNtFFs95Vk4NaJQ0JQj9uw==" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css" integrity="sha512-OAWSRzV0LxrNnjghIZJ97caW7u80YqEJgJlJlGkGv5bl/3TxAqSeknmT0nMvadbUzIUwoGDoeiTiXxE5u/vBRA==" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <script src="marked.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
      --bg-top: #11151c;
      --bg-bottom: #212d40;
      --panel-bg: rgba(17,21,28,0.6);
      --panel-bg-soft: rgba(17,21,28,0.3);
      --border: #364156;
      --border-soft: rgba(54,65,86,0.4);
      --accent: #7d4e57;
      --accent-hover: #915763;
      --text-main: #ffffff;
      --text-dim: #9aa4ba;
      --text-dimmer: rgba(154,164,186,0.6);
      --code-bg: #1a1f29;
      --code-fg: #e8e9f4;
      --chip-pass-bg: #1f3a2a;
      --chip-pass-fg: #85ffa8;
      --chip-warn-bg: #3a2f1f;
      --chip-warn-fg: #ffb37a;
      --chip-new-bg: #2f3442;
      --chip-new-fg: #d0d4e6;
      --spectator-overlay: rgba(0,0,0,0.85);
    }

    * {
      box-sizing:border-box;
      margin:0;
      padding:0;
      -webkit-font-smoothing: antialiased;
    }

    body {
      margin:0;
      font-family:system-ui, sans-serif;
      height:100vh;
      display:flex;
      background:
        radial-gradient(circle at 50% 30%, rgba(125,78,87,0.22) 0%, rgba(33,45,64,0) 60%),
        linear-gradient(to bottom, var(--bg-top) 0%, var(--bg-bottom) 100%);
      color:var(--text-main);
    }

    header {
      position:fixed;
      top:0; left:0; right:0;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:14px 20px;
      background:rgba(17,21,28,0.8);
      color:var(--text-main);
      z-index:10;
      box-shadow:0 24px 48px rgba(0,0,0,0.7), 0 2px 4px rgba(0,0,0,0.8);
      border-bottom:1px solid var(--border);
      backdrop-filter: blur(4px);
    }

    header h1 {
      font-size:18px;
      margin:0;
      letter-spacing:-0.03em;
      font-weight:600;
      color:var(--text-main);
    }

    header a {
      color:var(--text-main);
      text-decoration:none;
      font-weight:600;
      padding:8px 14px;
      border-radius:999px;
      background:rgba(125,78,87,0.18);
      border:1px solid rgba(125,78,87,0.4);
      box-shadow:0 16px 32px rgba(0,0,0,0.7);
      transition:all 0.15s ease;
      font-size:13px;
      line-height:1.2rem;
    }
    header a:hover {
      background:rgba(125,78,87,0.3);
      box-shadow:0 24px 48px rgba(0,0,0,0.8), 0 0 12px rgba(125,78,87,0.6);
    }

    .editor-panel {
      display:flex;
      flex-direction:column;
      flex:1;
      min-height:0;
    }

    .editor-panel .CodeMirror {
      flex:1;
      height:100%;
      min-height:0;
    }

    .CodeMirror {
      font-family:"JetBrains Mono","Fira Code","SFMono-Regular",monospace;
      font-size:14px;
      background:#282a36;
      color:#f8f8f2;
      border-radius:8px;
    }

    .CodeMirror-gutters {
      background:#282a36;
      border-right:1px solid #44475a;
    }

    .CodeMirror-focused {
      outline:none;
    }

    .cm-s-dracula.CodeMirror {
      background:#282a36;
      color:#f8f8f2;
    }
    .cm-s-dracula .CodeMirror-gutters {
      background:#282a36;
      border-right:1px solid #44475a;
    }
    .cm-s-dracula span.cm-keyword,
    .cm-s-dracula span.cm-operator {
      color:#ff79c6 !important;
    }
    .cm-s-dracula span.cm-string,
    .cm-s-dracula span.cm-string-2 {
      color:#f1fa8c !important;
    }
    .cm-s-dracula span.cm-number,
    .cm-s-dracula span.cm-atom {
      color:#bd93f9 !important;
    }
    .cm-s-dracula span.cm-comment {
      color:#6272a4 !important;
      font-style:italic;
    }
    .cm-s-dracula span.cm-def,
    .cm-s-dracula span.cm-builtin,
    .cm-s-dracula span.cm-variable-3 {
      color:#50fa7b !important;
    }
    .cm-s-dracula span.cm-variable,
    .cm-s-dracula span.cm-variable-2,
    .cm-s-dracula span.cm-tag {
      color:#8be9fd !important;
    }
    .cm-s-dracula span.cm-type {
      color:#8be9fd !important;
    }
    .cm-s-dracula span.cm-meta,
    .cm-s-dracula span.cm-qualifier {
      color:#ffb86c !important;
    }
    .cm-s-dracula span.cm-property {
      color:#66d9ef !important;
    }

    .wrap {
      flex:1;
      display:flex;
      height:100%;
      overflow:hidden;
      padding-top:70px;
      box-sizing:border-box;
    }

    .pane-left {
      flex-basis:50%;
      min-width:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      background:var(--panel-bg);
      border-right:2px solid var(--border);
      color:var(--text-main);
    }

    .pane-right {
      flex-basis:50%;
      min-width:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      background:var(--panel-bg);
      color:var(--text-main);
    }

    /* Divider ngang giữa 2 cột */
    .divider {
      width:8px;
      cursor:col-resize;
      background:rgba(54,65,86,0.4);
      position:relative;
      z-index:20;
      flex-shrink:0;
    }
    .divider::before {
      content:"";
      position:absolute;
      left:-6px;
      right:-6px;
      top:0;
      bottom:0;
    }

    /* ====== TRONG CỘT TRÁI: CHỈ ĐỀ BÀI ====== */
    .statement-panel {
      flex:1;
      min-height:0;
      display:flex;
      flex-direction:column;
      overflow:auto;
      padding:20px;
      background:var(--panel-bg);
      gap:16px;
    }

    .statement-header {
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:16px;
      flex-wrap:wrap;
    }

    .statement-header h2 {
      margin:0;
      font-size:22px;
      font-weight:600;
      color:var(--text-main);
      letter-spacing:-0.03em;
    }

    .statement-meta {
      margin-top:6px;
      font-size:13px;
      color:var(--text-dim);
      display:flex;
      gap:12px;
      flex-wrap:wrap;
    }

    .statement-meta span {
      display:inline-flex;
      align-items:center;
      gap:4px;
    }

    .statement-meta span + span::before {
      content:"•";
      margin-right:6px;
      color:var(--text-dimmer);
    }

    .statement-meta code {
      background:rgba(54,65,86,0.2);
      padding:2px 6px;
      border-radius:6px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
      font-size:12px;
      color:var(--text-main);
      border:1px solid rgba(54,65,86,0.4);
    }

    .badges-row {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .difficulty-badge {
      align-self:flex-start;
      padding:6px 14px;
      border-radius:999px;
      background:rgba(54,65,86,0.25);
      border:1px solid var(--border);
      font-size:13px;
      font-weight:700;
      letter-spacing:0.04em;
      text-transform:uppercase;
      color:var(--text-main);
    }

    .status-badge {
      align-self:flex-start;
      padding:6px 14px;
      border-radius:999px;
      font-size:12px;
      font-weight:700;
      letter-spacing:0.04em;
      text-transform:uppercase;
      background:var(--chip-new-bg);
      color:var(--chip-new-fg);
      border:1px solid rgba(208,212,230,0.25);
    }
    .status-badge.completed {
      background:var(--chip-pass-bg);
      color:var(--chip-pass-fg);
      border:1px solid rgba(133,255,168,0.4);
    }
    .status-badge.in-progress {
      background:var(--chip-warn-bg);
      color:var(--chip-warn-fg);
      border:1px solid rgba(255,179,122,0.4);
    }
    .status-badge.new {
      background:var(--chip-new-bg);
      color:var(--chip-new-fg);
      border:1px solid rgba(208,212,230,0.25);
    }

    .statement-body {
      display:flex;
      flex-direction:column;
      gap:18px;
      color:var(--text-main);
      font-size:14px;
    }

    .statement-section {
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .statement-section h3 {
      margin:0;
      font-size:16px;
      text-transform:uppercase;
      letter-spacing:0.04em;
      color:var(--text-dim);
      font-weight:600;
    }

    .statement-section p {
      margin:0;
      line-height:1.6;
      color:var(--text-main);
      font-size:14px;
    }

    .sample-block {
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    .sample-caption {
      font-size:12px;
      font-weight:600;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:var(--text-dimmer);
    }

    .sample-box {
      background:var(--code-bg);
      color:var(--code-fg);
      border-radius:10px;
      padding:14px 16px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
      font-size:13px;
      overflow:auto;
      box-shadow:inset 0 1px 2px rgba(0,0,0,0.6);
      border:1px solid var(--border-soft);
    }
    .sample-box code {
      white-space:pre;
      color:inherit;
    }

    .statement-body pre {
      background:var(--code-bg);
      border-radius:8px;
      padding:12px 14px;
      font-size:13px;
      overflow:auto;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
      border:1px solid var(--border-soft);
      color:var(--code-fg);
      box-shadow:inset 0 1px 2px rgba(0,0,0,0.6);
    }

    .right-vertical {
      flex:1;
      min-height:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
      background:var(--panel-bg);
    }

    .editor-panel {
      flex-basis:50%;
      min-height:0;
      overflow:auto;
      background:var(--panel-bg);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .results-panel {
      flex-basis:50%;
      min-height:0;
      overflow:auto;
      background:var(--panel-bg);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      border-top:2px solid var(--border);
    }

    .vertical-divider {
      height:8px;
      cursor:row-resize;
      background:rgba(54,65,86,0.4);
      position:relative;
      z-index:20;
      flex-shrink:0;
    }
    .vertical-divider::before {
      content:"";
      position:absolute;
      top:-6px;
      bottom:-6px;
      left:0;
      right:0;
    }

    .code-controls {
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
      color:var(--text-main);
      font-size:14px;
    }

    label {
      font-size:14px;
      font-weight:600;
      color:var(--text-main);
    }

    .language-picker {
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      color:var(--text-main);
    }

    .language-picker input { min-width:150px; }

    select,
    input {
      padding:6px 10px;
      border:1px solid var(--border);
      background:var(--panel-bg-soft);
      color:var(--text-main);
      border-radius:6px;
      font-size:14px;
      box-shadow:0 16px 32px rgba(0,0,0,0.6);
    }
    select { min-width:160px; }

    .language-picker select {
      min-width:180px;
    }

    .small-btn {
      background:var(--accent);
      color:#fff;
      border:1px solid var(--accent);
      border-radius:8px;
      padding:6px 12px;
      font-size:12px;
      font-weight:600;
      cursor:pointer;
      box-shadow:
        0 20px 40px rgba(0,0,0,0.7),
        0 2px 4px rgba(0,0,0,0.8),
        0 0 12px rgba(125,78,87,0.6);
      transition:all 0.15s ease;
    }
    .small-btn:hover {
      background:var(--accent-hover);
      border-color:var(--accent-hover);
      transform:translateY(-1px);
      box-shadow:
        0 30px 60px rgba(0,0,0,0.8),
        0 4px 8px rgba(0,0,0,0.9),
        0 0 16px rgba(145,87,99,0.7);
    }
    .small-btn:active { transform:translateY(0); }

    .help-text {
      font-size:12px;
      color:var(--text-dimmer);
    }

    textarea {
      flex:1;
      min-height:200px;
      padding:12px;
      resize:none;
      font-family:ui-monospace, monospace;
      font-size:14px;
      border:1px solid var(--border);
      border-radius:8px;
      background:var(--code-bg);
      color:var(--code-fg);
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.8);
    }

    textarea:focus {
      outline:2px solid var(--accent);
      background:#1f2531;
    }

    .status-line {
      font-weight:700;
      font-size:15px;
      color:var(--text-main);
    }

    .log-block {
      background:var(--code-bg);
      border-radius:8px;
      padding:12px;
      border:1px solid var(--border);
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.8);
      min-height:100px;
      overflow:auto;
      white-space:pre-wrap;
      font-size:13px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
      color:var(--code-fg);
    }

    .run-summary {
      background:var(--panel-bg-soft);
      border-radius:8px;
      padding:12px;
      border:1px solid var(--border);
      box-shadow:
        inset 0 1px 2px rgba(0,0,0,0.6),
        0 16px 32px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:10px;
      font-size:14px;
      color:var(--text-main);
    }

    .run-summary .overall {
      font-weight:700;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .run-summary .overall.pass { color:var(--chip-pass-fg); }
    .run-summary .overall.fail { color:#ff7a7a; }

    .run-tests {
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    .run-tests li {
      display:flex;
      justify-content:space-between;
      align-items:center;
      background:rgba(54,65,86,0.25);
      border-radius:6px;
      padding:6px 10px;
      font-weight:600;
      color:var(--text-main);
      border:1px solid var(--border-soft);
      font-size:13px;
    }

    .run-tests li.pass {
      color:var(--chip-pass-fg);
      background:var(--chip-pass-bg);
      border:1px solid rgba(133,255,168,0.4);
    }
    .run-tests li.fail {
      color:#ff7a7a;
      background:#3a1f1f;
      border:1px solid rgba(255,122,122,0.4);
    }

    .run-tests li span {
      font-size:12px;
      font-weight:500;
      color:var(--text-dimmer);
    }

    .run-metrics {
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      font-size:13px;
      color:var(--text-main);
    }

    .run-metrics div {
      background:rgba(54,65,86,0.25);
      border-radius:6px;
      padding:6px 10px;
      border:1px solid var(--border-soft);
    }

    .run-btn {
      align-self:flex-start;
      padding:15px 27px;
      background:var(--accent);
      color:#fff;
      border:1px solid var(--accent);
      border-radius:999px;
      font-size:14px;
      font-weight:600;
      cursor:pointer;
      box-shadow:
        0 24px 48px rgba(0,0,0,0.7),
        0 2px 4px rgba(0,0,0,0.8),
        0 0 16px rgba(125,78,87,0.6);
      transition:all 0.15s ease;
    }
    .run-btn:hover {
      background:var(--accent-hover);
      border-color:var(--accent-hover);
      box-shadow:
        0 32px 64px rgba(0,0,0,0.8),
        0 4px 8px rgba(0,0,0,0.9),
        0 0 20px rgba(145,87,99,0.8);
      transform:translateY(-1px);
    }
    .run-btn:active {
      transform:translateY(0);
    }

    .test-btn {
      background: rgba(54,65,86,0.8);
      border-color: var(--border);
      box-shadow:
        0 24px 48px rgba(0,0,0,0.7),
        0 2px 4px rgba(0,0,0,0.8);
    }
    .test-btn:hover {
      background: rgba(54,65,86,1);
      border-color: var(--border-soft);
      box-shadow:
        0 32px 64px rgba(0,0,0,0.8),
        0 4px 8px rgba(0,0,0,0.9);
    }

    .floating-runner {
      position:fixed;
      bottom:24px;
      right:24px;
      display:flex;
      gap:12px;
      z-index:1500;
      pointer-events:none;
    }
    .floating-runner .run-btn {
      pointer-events:auto;
    }
    @media (max-width:640px) {
      .floating-runner {
        left:16px;
        right:16px;
        bottom:16px;
        justify-content:center;
      }
      .floating-runner .run-btn {
        width:100%;
      }
    }

    body.resizing,
    body.resizing-vertical { user-select:none; }
    body.resizing { cursor:col-resize; }
    body.resizing-vertical { cursor:row-resize; }

    .spectator-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 10px 16px;
      background: rgba(125,78,87,0.9);
      color: #fff;
      border: 1px solid var(--accent);
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      transition: all 0.2s ease;
      display: none;
    }
    .spectator-toggle:hover {
      background: rgba(145,87,99,0.95);
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(0,0,0,0.7);
    }
    .spectator-toggle.active {
      background: #4a9eff;
      border-color: #4a9eff;
    }

    .winner-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.92);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }
    .winner-modal.show {
      display: flex;
    }

    .winner-content {
      background: linear-gradient(135deg, var(--bg-top) 0%, var(--bg-bottom) 100%);
      border: 3px solid var(--accent);
      border-radius: 20px;
      width: 90%;
      max-width: 600px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.9), 0 0 40px rgba(125,78,87,0.5);
      animation: slideUp 0.4s ease;
    }

    @keyframes slideUp {
      from { 
        opacity: 0;
        transform: translateY(50px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }

    .winner-emoji {
      font-size: 80px;
      margin-bottom: 20px;
      animation: bounce 1s ease infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }

    .winner-title {
      font-size: 32px;
      font-weight: 700;
      color: var(--text-main);
      margin-bottom: 10px;
      letter-spacing: -0.03em;
    }

    .winner-subtitle {
      font-size: 18px;
      color: var(--text-dim);
      margin-bottom: 30px;
    }

    .winner-stats {
      background: rgba(17,21,28,0.6);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 30px;
      text-align: left;
    }

    .winner-stats h3 {
      font-size: 14px;
      color: var(--text-dim);
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .winner-players {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .winner-player {
      background: rgba(54,65,86,0.3);
      border-radius: 8px;
      padding: 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border: 2px solid transparent;
      transition: all 0.2s ease;
    }

    .winner-player.winner {
      border-color: var(--chip-pass-fg);
      background: var(--chip-pass-bg);
    }

    .winner-player-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--text-main);
    }

    .winner-player-metrics {
      font-size: 13px;
      color: var(--text-dim);
      font-family: ui-monospace, monospace;
      display: grid;
      gap: 4px;
    }

    .winner-scoreboard {
      margin-top: 18px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .winner-scoreboard-title {
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--text-dim);
    }

    .winner-scoreboard-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: ui-monospace, monospace;
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 6px;
      background: rgba(54,65,86,0.25);
      border: 1px solid var(--border-soft);
    }

    .winner-actions {
      display: flex;
      gap: 15px;
      justify-content: center;
    }

    .winner-btn {
      padding: 14px 28px;
      font-size: 16px;
      font-weight: 600;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid;
    }

    .winner-btn-primary {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 8px 20px rgba(125,78,87,0.5);
    }

    .winner-btn-primary:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 12px 30px rgba(145,87,99,0.6);
    }

    .winner-btn-secondary {
      background: transparent;
      color: var(--text-main);
      border-color: var(--border);
    }

    .winner-btn-secondary:hover {
      background: rgba(54,65,86,0.3);
      border-color: var(--text-main);
    }

    .spectator-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--spectator-overlay);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease;
    }
    .spectator-modal.show {
      display: flex;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .spectator-content {
      background: var(--bg-top);
      border: 2px solid var(--border);
      border-radius: 12px;
      width: 90%;
      max-width: 1200px;
      height: 80%;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0,0,0,0.8);
    }

    .spectator-header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .spectator-header h3 {
      margin: 0;
      color: var(--text-main);
      font-size: 18px;
    }

    .spectator-close {
      background: transparent;
      border: none;
      color: var(--text-dim);
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .spectator-close:hover {
      background: rgba(255,255,255,0.1);
      color: var(--text-main);
    }

    .spectator-body {
      flex: 1;
      padding: 20px;
      overflow: auto;
    }

    .spectator-code {
      width: 100%;
      height: 100%;
      background: var(--code-bg);
      color: var(--code-fg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      font-family: 'Fira Code', 'Consolas', monospace;
      font-size: 14px;
      line-height: 1.6;
      resize: none;
      white-space: pre;
      overflow: auto;
    }

    .spectator-status {
      padding: 8px 16px;
      background: rgba(74, 158, 255, 0.2);
      border-left: 3px solid #4a9eff;
      color: #4a9eff;
      font-size: 13px;
      margin-bottom: 12px;
      border-radius: 4px;
    }

    @media (max-width: 900px) {
      .wrap { flex-direction:column; }
      .divider {
        height:8px;
        width:auto;
        cursor:row-resize;
      }
      .divider::before {
        left:0;
        right:0;
        top:-6px;
        bottom:-6px;
      }
      .pane-left {
        border-right:0;
        border-bottom:2px solid var(--border);
      }
    }
  </style>
</head>
<body>

<button class="spectator-toggle" id="spectatorToggle">
  View Opponent Code
</button>

<div class="winner-modal" id="winnerModal">
  <div class="winner-content">
    <div class="winner-emoji" id="winnerEmoji"></div>
    <h2 class="winner-title" id="winnerTitle">Match Complete!</h2>
    <p class="winner-subtitle" id="winnerSubtitle">Results are in</p>
    
    <div class="winner-stats">
      <h3>Performance Comparison</h3>
      <div class="winner-players" id="winnerPlayers">
        <!-- Player stats will be populated here -->
      </div>
    </div>

    <div class="winner-actions">
      <button class="winner-btn winner-btn-secondary" id="backToRoomBtn">
        ← Main Menu
      </button>
      <button class="winner-btn winner-btn-primary" id="continueBtn" style="display:none;">
        Continue Next Round →
      </button>
    </div>
  </div>
</div>

<div class="spectator-modal" id="spectatorModal">
  <div class="spectator-content">
    <div class="spectator-header">
      <h3>Opponent Code (Real-time)</h3>
      <button class="spectator-close" id="spectatorClose">&times;</button>
    </div>
    <div class="spectator-body">
      <div class="spectator-status" id="spectatorStatus">
        Waiting for opponent to write code...
      </div>
      <textarea class="spectator-code" id="opponentCode" readonly></textarea>
    </div>
  </div>
</div>

<header>
  <a href="/mainmenu.html" style="text-decoration:none; color:inherit;">
    <h1>Coduel</h1>
  </a>
</header>

<div class="wrap" id="split">
  <!-- CỘT TRÁI: ĐỀ BÀI -->
  <div class="pane-left" id="left-pane">
    <section class="statement-panel" id="statement-panel">
      <div class="statement-header">
        <div>
          <h2 id="statement-title">Problem</h2>
          <div class="statement-meta">
            <span id="problem-meta"></span>
          </div>
        </div>
        <div class="badges-row">
          <span class="difficulty-badge" id="difficulty">Difficulty: unknown</span>
          <span class="status-badge" id="status-badge">Status: new</span>
        </div>
      </div>

      <div id="statement-body" class="statement-body">
        Select a problem to view its statement.
      </div>
    </section>
  </div>

  <!-- DIVIDER NGANG -->
  <div class="divider" id="divider"></div>

  <!-- CỘT PHẢI: TRÊN = CODE, DƯỚI = KẾT QUẢ -->
  <div class="pane-right" id="right-pane">
    <div class="right-vertical" id="vertical">
      <!-- EDITOR TRÊN -->
      <section class="editor-panel" id="editor-panel">
        <div class="code-controls">
          <label for="pid">Problem:</label>
          <select id="pid"></select>
          <button type="button" class="small-btn" id="refresh-problems">Refresh</button>

          <label for="lang-select">Language:</label>
          <div class="language-picker">
            <select id="lang-select"></select>
            <input id="lang-input" list="language-options" placeholder="Search language..." />
            <datalist id="language-options"></datalist>
          </div>

        </div>

        <textarea id="code">// C++20 sample
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    long long a,b; if(!(cin&gt;&gt;a&gt;&gt;b)) return 0;
    cout &lt;&lt; (a+b) &lt;&lt; "\n";
    return 0;
}
        </textarea>
      </section>

      <!-- DIVIDER DỌC -->
      <div class="vertical-divider" id="vertical-divider"></div>

      <!-- KẾT QUẢ DƯỚI -->
      <section class="results-panel" id="results-panel">
        <div class="status-line">Status: <span id="status">idle</span></div>

        <div>
          <strong>Compile log</strong>
          <pre class="log-block" id="clog"></pre>
        </div>

        <div>
          <strong>Run result</strong>
          <div class="run-summary" id="run-summary">No results yet.</div>
          <pre class="log-block" id="rlog" style="display:none;"></pre>
        </div>
      </section>
    </div>
  </div>
</div>

<div class="floating-runner">
  <button id="btnTest" class="run-btn test-btn">Run Test</button>
  <button id="btn" class="run-btn">Compile &amp; Run</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js" integrity="sha512-+nQO2ofnUeJgHYa/u/l0iW+EYhIn0R+ifR+BedJEryD91XfMPogv+0h/rbpIKlLeuUp2U7fXKAGeevSjT0H2rA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js" integrity="sha512-Ecox18y9Gd8Fr7k3mgf0DnOVhBL+J1T7/CqCjeyboGUpOZlyt+9BJq/sIBsDCQPSWx7QLnyM8WB0+uClJmu9uA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js" integrity="sha512-WBYC4kBlA2zV8LOlCY9mk8kbMZ+j51N77r3WDYt1TnO4xjP0dsc7pQqAS8dXBj4RoXLOdAxW2P8Fs14r9WQ9jw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js" integrity="sha512-SyU9H33+G3xg3AdKNOeWn5xu2L/c9WTvV6t6SjbUSKX63dBC2WJUPZ5TxfsxM5ZcgbiqCLu9Vkm8NyX9SkwkAA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/python/python.min.js" integrity="sha512-6yv/wEMzS1MbmS6nzu1Se0kGkcs8EwScegXHPelqXcRIf+B7JhYLIK+QJgF2abRbS2l63ZqN0z8qJcGf7YpgiA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js" integrity="sha512-sM1iyOH1cwz0MB6Nmhqi2uYUiQR6AGSxgSeWVkYKUrBVkyPf5MgsMVSMaOJW9f2FmAel4JcwCBmdsUWaXZpXOg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<!-- Socket.IO Client -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="/socket-client.js"></script>

<script>


const api = "/api"; 

const btn = document.getElementById("btn");
const btnTest = document.getElementById("btnTest");
const statusEl = document.getElementById("status");
const clog = document.getElementById("clog");
const rlog = document.getElementById("rlog");
const runSummary = document.getElementById("run-summary");

const pidInput = document.getElementById("pid");
const refreshBtn = document.getElementById("refresh-problems");

const langSelect = document.getElementById("lang-select");
const langInput = document.getElementById("lang-input");
const langOptionsEl = document.getElementById("language-options");

const statementBody = document.getElementById("statement-body");
const statementTitle = document.getElementById("statement-title");
const difficultyBadge = document.getElementById("difficulty");
const statusBadge = document.getElementById("status-badge");
const problemMeta = document.getElementById("problem-meta");

const leftPane = document.getElementById("left-pane");
const rightPane = document.getElementById("right-pane");
const divider = document.getElementById("divider");
const split = document.getElementById("split");

const vertical = document.getElementById("vertical");
const editorPanel = document.getElementById("editor-panel");
const resultsPanel = document.getElementById("results-panel");
const verticalDivider = document.getElementById("vertical-divider");

const codeArea = document.getElementById("code");
document.querySelectorAll("textarea").forEach((el) => {
  el.setAttribute("spellcheck", "false");
  el.setAttribute("autocorrect", "off");
  el.setAttribute("autocapitalize", "off");
  el.setAttribute("autocomplete", "off");
});

let codeEditor = null;
let suppressCodeChangeEvent = false;

const editorModeMap = {
  cpp: "text/x-c++src",
  c: "text/x-csrc",
  py: "python",
  java: "text/x-java",
  js: "javascript"
};

if (window.CodeMirror && codeArea) {
  codeEditor = CodeMirror.fromTextArea(codeArea, {
    mode: "text/x-c++src",
    theme: "dracula",
    lineNumbers: true,
    matchBrackets: true,
    autoCloseBrackets: "()[]{}''\"\"``",
    lineWrapping: false,
    indentUnit: 4,
    indentWithTabs: false,
    tabSize: 4,
    extraKeys: {
      Tab: (cm) => {
        if (cm.somethingSelected()) {
          cm.indentSelection("add");
        } else {
          cm.replaceSelection("    ", "end");
        }
      },
      "Shift-Tab": (cm) => {
        if (cm.somethingSelected()) {
          cm.indentSelection("subtract");
        } else {
          const cursor = cm.getCursor();
          cm.execCommand("indentLess");
          cm.setCursor({ line: cursor.line, ch: Math.max(cursor.ch - 4, 0) });
        }
      }
    }
  });
  codeEditor.setSize("100%", "100%");
  codeArea.style.display = "none";
  const cmInput = codeEditor.getInputField();
  cmInput.setAttribute("spellcheck", "false");
  cmInput.setAttribute("autocorrect", "off");
  cmInput.setAttribute("autocapitalize", "off");
  cmInput.setAttribute("autocomplete", "off");
  cmInput.setAttribute("inputmode", "text");
  setTimeout(() => codeEditor.refresh(), 0);
  applyEditorMode("cpp");
}

function getCodeValue() {
  return codeEditor ? codeEditor.getValue() : codeArea.value;
}

function setCodeValue(value, { silent = false } = {}) {
  if (codeEditor) {
    suppressCodeChangeEvent = silent;
    codeEditor.setValue(value !== undefined ? value : "");
    if (!silent) {
      suppressCodeChangeEvent = false;
    } else {
      setTimeout(() => {
        suppressCodeChangeEvent = false;
      }, 0);
    }
  } else {
    suppressCodeChangeEvent = silent;
    codeArea.value = value !== undefined ? value : "";
    suppressCodeChangeEvent = false;
  }
}

function focusCodeEditor() {
  if (codeEditor) {
    codeEditor.focus();
  } else if (codeArea) {
    codeArea.focus();
  }
}

function applyEditorMode(langCode) {
  if (!codeEditor) return;
  const mode = editorModeMap[langCode] || editorModeMap.cpp;
  codeEditor.setOption("mode", mode);
}

const STATUS_KEY = "oj-problem-status";
const urlParams = new URLSearchParams(window.location.search);
const initialProblemId = urlParams.get("pid") || "";
const DEFAULT_LANGUAGE = "cpp";
const roomCodeParam = urlParams.get("room") || "";
const isOnlineMode = Boolean(roomCodeParam);
const initialLanguageParam = urlParams.get("lang") || "";

if (isOnlineMode) {
  const cleanUrl = new URL(window.location.href);
  if (cleanUrl.searchParams.has("lang")) {
    cleanUrl.searchParams.delete("lang");
    history.replaceState(null, "", cleanUrl);
  }
}

const LANGUAGE_ALIASES = {
  "c++": "cpp",
  "python": "py",
  "java": "java",
  "javascript": "js",
  "node": "js"
};

const LANGUAGE_OPTIONS = [
  { code: "cpp", label: "C++ (C++20)", sample: `// C++20 sample\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    long long a,b;\n    if(!(cin>>a>>b)) return 0;\n    cout << (a+b) << "\\n";\n    return 0;\n}` },
  { code: "c", label: "C (C17)", sample: `// C17 sample\n#include <stdio.h>\nint main(void){\n    long long a,b;\n    if(scanf("%lld %lld", &a, &b)!=2) return 0;\n    printf("%lld\\n", a+b);\n    return 0;\n}` },
  { code: "py", label: "Python 3", sample: `# Python 3 sample\nimport sys\nline = sys.stdin.readline().strip()\nif line:\n    a, b = map(int, line.split())\n    print(a + b)` },
  { code: "java", label: "Java 17", sample: `import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        FastScanner fs = new FastScanner(System.in);\n        long a = fs.nextLong();\n        long b = fs.nextLong();\n        System.out.println(a + b);\n    }\n    static class FastScanner {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1 << 16];\n        private int ptr = 0, len = 0;\n        FastScanner(InputStream is) { in = is; }\n        private int read() throws IOException {\n            if (ptr >= len) {\n                len = in.read(buffer);\n                ptr = 0;\n                if (len <= 0) return -1;\n            }\n            return buffer[ptr++];\n        }\n        long nextLong() throws IOException {\n            int c; do { c = read(); } while (c <= ' ');\n            long sign = 1;\n            if (c == '-') { sign = -1; c = read(); }\n            long val = c - '0';\n            while ((c = read()) > ' ') val = val * 10 + c - '0';\n            return val * sign;\n        }\n    }\n}` },
  { code: "js", label: "JavaScript (Node)", sample: `// JavaScript (Node) sample\nconst fs = require('fs');\nconst input = fs.readFileSync(0,'utf8').trim().split(/\\s+/);\nif (input.length >= 2) {\n  const a = BigInt(input[0]);\n  const b = BigInt(input[1]);\n  console.log((a + b).toString());\n}` }
];

let problemsCache = [];
let currentProblemId = initialProblemId;
let currentLanguage = DEFAULT_LANGUAGE;
let userTouchedCode = false;
const languageMap = new Map();
let matchSettings = null;

const difficultyLabels = {
  fast: "Fast",
  easy: "Easy",
  medium: "Medium",
  hard: "Hard"
};

function loadStatuses() {
  try {
    return JSON.parse(localStorage.getItem(STATUS_KEY) || "{}");
  } catch {
    return {};
  }
}

function getProblemStatus(problemId) {
  if (!problemId) return "new";
  const statuses = loadStatuses();
  return statuses[problemId] || "new";
}

function setProblemStatus(problemId, status) {
  if (!problemId) return;
  const statuses = loadStatuses();
  statuses[problemId] = status;
  localStorage.setItem(STATUS_KEY, JSON.stringify(statuses));
}

function statusLabel(status) {
  if (status === "completed") return "Completed";
  if (status === "in-progress") return "In Progress";
  return "Not Started";
}

function updateStatusBadge() {
  if (!statusBadge) return;
  if (!currentProblemId) {
    statusBadge.textContent = "Status: –";
    statusBadge.className = "status-badge new";
    return;
  }
  const status = getProblemStatus(currentProblemId);
  statusBadge.textContent = `Status: ${statusLabel(status)}`;
  statusBadge.className = `status-badge ${status}`;
}

function updateStatusFromMeta(metaStatus) {
  if (!currentProblemId) return;
  const normalized = String(metaStatus || "").toLowerCase();
  if (normalized === "done") {
    setProblemStatus(currentProblemId, "completed");
  } else if (["failed", "compile_error", "error", "run_timeout", "compile_timeout"].includes(normalized)) {
    setProblemStatus(currentProblemId, "in-progress");
  } else if (["queued", "compiled", "compiling"].includes(normalized)) {
    setProblemStatus(currentProblemId, "in-progress");
  }
  updateStatusBadge();
}

function populateLanguageOptions() {
  languageMap.clear();
  langOptionsEl.innerHTML = "";
  if (langSelect) {
    langSelect.innerHTML = "";
  }
  LANGUAGE_OPTIONS.forEach(({ code, label, sample }) => {
    languageMap.set(code, { code, label, sample });
    const option = document.createElement("option");
    option.value = code;
    option.label = label;
    langOptionsEl.appendChild(option);
    if (langSelect) {
      const selectOption = document.createElement("option");
      selectOption.value = code;
      selectOption.textContent = label;
      langSelect.appendChild(selectOption);
    }
  });
  if (langSelect) {
    langSelect.value = currentLanguage;
  }
}

function normalizeLanguage(value) {
  const code = String(value || "").trim().toLowerCase();
  if (languageMap.has(code)) return code;
  if (LANGUAGE_ALIASES[code]) {
    return LANGUAGE_ALIASES[code];
  }
  return DEFAULT_LANGUAGE;
}

function setLanguage(code, { forceSample = false } = {}) {
  const previousLanguage = currentLanguage;
  const previousOption = languageMap.get(previousLanguage);
  const normalized = normalizeLanguage(code);
  const option = languageMap.get(normalized);
  currentLanguage = normalized;
  applyEditorMode(normalized);
  if (langSelect && langSelect.value !== normalized) {
    langSelect.value = normalized;
  }
  langInput.value = normalized;
  if (!isOnlineMode) {
    const url = new URL(window.location.href);
    if (normalized === DEFAULT_LANGUAGE) {
      url.searchParams.delete("lang");
    } else {
      url.searchParams.set("lang", normalized);
    }
    history.replaceState(null, "", url);
  }
  if (!option) return;
  const previousSample = previousOption ? (previousOption.sample || "").trim() : "";
  const currentValue = getCodeValue().trim();
  const shouldUpdateSample = forceSample || !userTouchedCode || (!!previousSample && currentValue === previousSample);
  if (shouldUpdateSample) {
    if (option.sample) {
      setCodeValue(option.sample, { silent: true });
      userTouchedCode = false;
    }
  }
}

function enforceHostLanguage(languageValue) {
  if (!isOnlineMode || !languageValue) return;
  const normalized = normalizeLanguage(languageValue);
  setLanguage(normalized);
}

async function loadStatement(problemId) {
  console.log('loadStatement called with:', problemId);
  if (!problemId) {
    console.warn('Empty problemId, showing default message');
    statementTitle.textContent = "Problem";
    problemMeta.innerHTML = "";
    statementBody.textContent = "Select a problem to view its statement.";
    difficultyBadge.textContent = "Difficulty: unknown";
    statusEl.textContent = "idle";
    clog.textContent = "";
    renderRunResult(null);
    currentProblemId = "";
    updateStatusBadge();
    return;
  }

  currentProblemId = problemId;
  updateStatusBadge();
  statusEl.textContent = "idle";
  clog.textContent = "";
  renderRunResult(null);
  problemMeta.innerHTML = `<span>ID: <code>${escapeHtml(problemId)}</code></span>`;
  statementTitle.textContent = `Problem: ${problemId}`;
  statementBody.textContent = "Loading statement...";
  difficultyBadge.textContent = "Difficulty: …";

  try {
    console.log(`Fetching problem from: ${api}/problem/${encodeURIComponent(problemId)}`);
    const res = await fetch(`${api}/problem/${encodeURIComponent(problemId)}`);
    console.log(`API response status: ${res.status}`);
    if (!res.ok) throw new Error(res.statusText);
    const data = await res.json();
    console.log('Problem data loaded:', data.problem_id, data.title);

    const diffLabel = difficultyLabels[data.difficulty] || (data.difficulty || "unknown");
    difficultyBadge.textContent = `Difficulty: ${diffLabel}`;

    const metaBits = [`<span>ID: <code>${escapeHtml(problemId)}</code></span>`];
    if (typeof data.number === "number") {
      metaBits.push(`<span>Problem #${data.number}</span>`);
    }
    const timeDisplay = formatTimeLimit(data.time_limit_ms);
    if (timeDisplay) {
      metaBits.push(`<span>Time limit: ${timeDisplay}</span>`);
    }
    const memoryDisplay = formatMemory(data.memory_limit_kb);
    if (memoryDisplay) {
      metaBits.push(`<span>Memory: ${memoryDisplay}</span>`);
    }
    if (data.tests_summary && data.tests_summary.total) {
      const publicCount = data.tests_summary.public ?? 0;
      const hiddenCount = data.tests_summary.hidden ?? 0;
      let testsLabel = `${data.tests_summary.total} total`;
      if (publicCount && hiddenCount) {
        testsLabel += ` (${publicCount} public)`;
      } else if (publicCount) {
        testsLabel += ` (${publicCount} public)`;
      }
      metaBits.push(`<span>Tests: ${testsLabel}</span>`);
    }
    if (Array.isArray(data.tags) && data.tags.length) {
      metaBits.push(`<span>Tags: ${data.tags.map(escapeHtml).join(", ")}</span>`);
    }
    problemMeta.innerHTML = metaBits.join("");

    const info = renderStatementContent(data.statement || "");
    let displayTitle = data.title || info.title || null;
    if (displayTitle) {
      if (typeof data.number === "number" && !/^problem\s*\d+/i.test(displayTitle)) {
        statementTitle.textContent = `Problem ${data.number}: ${displayTitle}`;
      } else {
        statementTitle.textContent = displayTitle;
      }
    } else {
      statementTitle.textContent = `Problem: ${problemId}`;
    }

    if (!info.hasSample && Array.isArray(data.samples) && data.samples.length) {
      appendSampleSections(data.samples);
    }
    updateStatusBadge();
  } catch (err) {
    statementBody.textContent = "Unable to load statement.";
    difficultyBadge.textContent = "Difficulty: unknown";
    problemMeta.innerHTML = `<span>ID: <code>${escapeHtml(problemId)}</code></span>`;
    console.error(err);
    updateStatusBadge();
  }
}

/* RESIZE NGANG: cột trái / cột phải */
let isDragging = false;
divider.addEventListener("mousedown", () => {
  isDragging = true;
  document.body.classList.add("resizing");
});
window.addEventListener("mousemove", (e) => {
  if (!isDragging) return;
  const rect = split.getBoundingClientRect();
  let percent = ((e.clientX - rect.left) / rect.width) * 100;
  percent = Math.min(75, Math.max(25, percent));
  leftPane.style.flexBasis = `${percent}%`;
  rightPane.style.flexBasis = `${100 - percent}%`;
});
window.addEventListener("mouseup", () => {
  if (isDragging) {
    isDragging = false;
    document.body.classList.remove("resizing");
  }
});

/* RESIZE DỌC: editor trên / results dưới (chỉ trong cột phải) */
let isVerticalDragging = false;
verticalDivider.addEventListener("mousedown", () => {
  isVerticalDragging = true;
  document.body.classList.add("resizing-vertical");
});
window.addEventListener("mousemove", (e) => {
  if (!isVerticalDragging) return;
  const rect = vertical.getBoundingClientRect();
  let percent = ((e.clientY - rect.top) / rect.height) * 100;
  percent = Math.min(75, Math.max(25, percent));
  editorPanel.style.flexBasis = `${percent}%`;
  resultsPanel.style.flexBasis = `${100 - percent}%`;
});
window.addEventListener("mouseup", () => {
  if (isVerticalDragging) {
    isVerticalDragging = false;
    document.body.classList.remove("resizing-vertical");
  }
});

/* select problem */
pidInput.addEventListener("change", async () => {
  const value = pidInput.value;
  currentProblemId = value;
  clog.textContent = "";
  renderRunResult(null);
  const url = new URL(window.location.href);
  if (value) {
    url.searchParams.set("pid", value);
  } else {
    url.searchParams.delete("pid");
  }
  history.replaceState(null, "", url);
  if (value) {
    await loadStatement(value);
  } else {
    await loadStatement("");
  }
});
refreshBtn.addEventListener("click", () => loadProblemOptions(true));

/* language handling */
populateLanguageOptions();
if (isOnlineMode) {
  if (langSelect) {
    langSelect.disabled = true;
    langSelect.title = "Language is locked by the host";
  }
  if (langInput) {
    langInput.disabled = true;
    langInput.placeholder = "Locked by host";
    langInput.title = "Language is locked by the host";
  }
  setLanguage(DEFAULT_LANGUAGE, { forceSample: true });
} else {
  setLanguage(initialLanguageParam || DEFAULT_LANGUAGE, { forceSample: true });
  if (langSelect) {
    langSelect.addEventListener("change", () => setLanguage(langSelect.value));
  }
  langInput.addEventListener("change", () => setLanguage(langInput.value));
  langInput.addEventListener("blur", () => setLanguage(langInput.value));
  langInput.addEventListener("input", () => {
    const normalized = normalizeLanguage(langInput.value);
    if (languageMap.has(normalized)) {
      currentLanguage = normalized;
    }
  });
}

function handleCodeInputChange() {
  if (suppressCodeChangeEvent) {
    suppressCodeChangeEvent = false;
    return;
  }
  userTouchedCode = true;
  if (currentProblemId) {
    setProblemStatus(currentProblemId, "in-progress");
    updateStatusBadge();
  }
}

if (codeEditor) {
  codeEditor.on("change", handleCodeInputChange);
} else if (codeArea) {
  codeArea.addEventListener("input", handleCodeInputChange);
  codeArea.addEventListener("keydown", (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      const start = codeArea.selectionStart;
      const end = codeArea.selectionEnd;
      const insert = "    ";
      const value = codeArea.value;
      codeArea.value = value.slice(0, start) + insert + value.slice(end);
      codeArea.selectionStart = codeArea.selectionEnd = start + insert.length;
      handleCodeInputChange();
      return;
    }

    const pairs = {
      "(": ")",
      "[": "]",
      "{": "}",
      "'": "'",
      '"': '"',
      "`": "`"
    };

    if (pairs[event.key]) {
      event.preventDefault();
      const start = codeArea.selectionStart;
      const end = codeArea.selectionEnd;
      const value = codeArea.value;
      const selected = value.slice(start, end);
      const open = event.key;
      const close = pairs[event.key];
      const insertText = selected ? open + selected + close : open + close;
      codeArea.value = value.slice(0, start) + insertText + value.slice(end);
      const cursorOffset = open.length;
      const newCursor = start + cursorOffset;
      if (selected) {
        codeArea.selectionStart = start + cursorOffset;
        codeArea.selectionEnd = start + cursorOffset + selected.length;
      } else {
        codeArea.selectionStart = codeArea.selectionEnd = newCursor;
      }
      handleCodeInputChange();
    }
  });
}

/* load problem list ban đầu */
async function loadProblemOptions(autoSelect = false) {
  console.log('loadProblemOptions called, autoSelect:', autoSelect, 'currentProblemId:', currentProblemId);
  try {
    const res = await fetch(`${api}/problems`);
    if (!res.ok) throw new Error(res.statusText);
    const data = await res.json();
    problemsCache = Array.isArray(data.problems) ? data.problems : [];
    console.log(`Loaded ${problemsCache.length} problems`);
  } catch (err) {
    console.error('Error loading problems:', err);
    problemsCache = [];
  }

  pidInput.innerHTML = "";

  if (!problemsCache.length) {
    console.warn('No problems found');
    const option = document.createElement("option");
    option.value = "";
    option.textContent = "No problems available";
    pidInput.appendChild(option);
    pidInput.disabled = true;
    currentProblemId = "";
    loadStatement("");
    updateStatusBadge();
    return;
  }

  // Disable problem selection in online mode (will be set by host)
  if (isOnlineMode) {
    pidInput.disabled = true;
    pidInput.title = "Problem is selected when match starts";
  } else {
    pidInput.disabled = false;
    pidInput.title = "";
  }

  problemsCache.forEach((item) => {
    const option = document.createElement("option");
    option.value = item.problem_id;
    const numberLabel = typeof item.number === "number"
      ? `${String(item.number).padStart(3, "0")} · `
      : "";
    const diffLabel = difficultyLabels[item.difficulty] || (item.difficulty || "unknown");
    option.textContent = `${numberLabel}${item.title || item.problem_id} (${diffLabel})`;
    pidInput.appendChild(option);
  });

  // In online mode without a problem selected yet, show waiting message
  if (isOnlineMode && !currentProblemId) {
    console.log('Online mode: waiting for match to start');
    pidInput.value = "";
    statementBody.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Waiting for host to start the match...</div>';
    difficultyBadge.textContent = "Difficulty: waiting...";
    updateStatusBadge();
    return;
  }

  // Determine which problem to select
  const desired = currentProblemId && problemsCache.some(p => p.problem_id === currentProblemId)
    ? currentProblemId
    : (isOnlineMode ? "" : problemsCache[0].problem_id);

  console.log('Desired problem:', desired, 'currentProblemId:', currentProblemId, 'isOnlineMode:', isOnlineMode);
  
  if (desired) {
    pidInput.value = desired;
    currentProblemId = desired;
    updateStatusBadge();
    
    // Always load the statement if we have a desired problem
    console.log('Loading statement for problem:', desired);
    await loadStatement(desired);
  } else {
    // No problem to load (shouldn't happen after the check above)
    console.log('No desired problem, showing empty state');
    pidInput.value = "";
    loadStatement("");
  }
}

/* nút Compile & Run */
btn.onclick = async () => {
  statusEl.textContent = "submitting...";
  clog.textContent = ""; rlog.textContent = "";
  renderRunResult(null);

  const langCode = normalizeLanguage(langInput.value);
  setLanguage(langCode);

  const body = {
    language: langCode,
    code: getCodeValue(),
    problem_id: document.getElementById("pid").value,
    opt: "O2"
  };

  if (!body.problem_id) {
    statusEl.textContent = "Please choose a problem before submitting.";
    return;
  }
  if (!languageMap.has(body.language)) {
    statusEl.textContent = "Unsupported language selection.";
    return;
  }

  if (currentProblemId) {
    setProblemStatus(currentProblemId, "in-progress");
    updateStatusBadge();
  }

  try {
    const res = await fetch(api + "/problem/submit", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      const errText = await res.text();
      statusEl.textContent = `submit failed (${res.status})`;
      console.error("Submit failed:", errText);
      return;
    }
    const js = await res.json();
    const id = js.submission_id;
    console.log('Submission ID:', id);
    statusEl.textContent = "queued ("+id+")";
    
    // Notify opponent via socket if in multiplayer mode
    if (currentRoomCode) {
      socketClient.submitCode(currentRoomCode, id);
      console.log('Notified room about submission:', id);
    }

    let tries=0;
    while (tries<120) {
      await new Promise(r=>setTimeout(r,1000));
      console.log(`Polling attempt ${tries+1}/120 for submission ${id}`);
      const sres = await fetch(api + "/problem/submission/" + id);
      if (!sres.ok) {
        console.error(`Polling failed: ${sres.status} ${sres.statusText}`);
        break;
      }
      const data = await sres.json();
      console.log('Status update:', data.meta.status, data);
      statusEl.textContent = data.meta.status;
      updateStatusFromMeta(data.meta.status);
      if (data.compile_log) clog.textContent = data.compile_log;
      renderRunResult(data.run_result);
      if ([
        "done","failed","compile_error","error",
        "run_timeout","compile_timeout","problem_not_found"
      ].includes(data.meta.status)) {
        console.log('Final status reached:', data.meta.status);
        break;
      }
      tries++;
    }
    if (tries >= 120) {
      console.warn('Polling timeout after 120 attempts');
      statusEl.textContent = "timeout - check manually";
    }
  } catch (err) {
    statusEl.textContent = "submit failed";
    console.error('Submit error:', err);
  }
};

/* nút Run Test - chỉ test với public/sample test cases */
btnTest.onclick = async () => {
  statusEl.textContent = "submitting test...";
  clog.textContent = ""; rlog.textContent = "";
  renderRunResult(null);

  const langCode = normalizeLanguage(langInput.value);
  setLanguage(langCode);

  const body = {
    language: langCode,
    code: getCodeValue(),
    problem_id: document.getElementById("pid").value,
    opt: "O2",
    test_mode: "sample_only"
  };

  if (!body.problem_id) {
    statusEl.textContent = "Please choose a problem before testing.";
    return;
  }
  if (!languageMap.has(body.language)) {
    statusEl.textContent = "Unsupported language selection.";
    return;
  }

  try {
    const res = await fetch(api + "/problem/submit", {
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      const errText = await res.text();
      statusEl.textContent = `test submit failed (${res.status})`;
      console.error("Test submit failed:", errText);
      return;
    }
    const js = await res.json();
    const id = js.submission_id;
    console.log('Test Submission ID:', id);
    statusEl.textContent = "testing ("+id+")";

    let tries=0;
    while (tries<120) {
      await new Promise(r=>setTimeout(r,1000));
      console.log(`Polling test attempt ${tries+1}/120 for submission ${id}`);
      const sres = await fetch(api + "/problem/submission/" + id);
      if (!sres.ok) {
        console.error(`Polling failed: ${sres.status} ${sres.statusText}`);
        break;
      }
      const data = await sres.json();
      console.log('Test status update:', data.meta.status, data);
      statusEl.textContent = data.meta.status;
      updateStatusFromMeta(data.meta.status);
      if (data.compile_log) clog.textContent = data.compile_log;
      renderRunResult(data.run_result);
      if ([
        "done","failed","compile_error","error",
        "run_timeout","compile_timeout","problem_not_found"
      ].includes(data.meta.status)) {
        console.log('Final test status reached:', data.meta.status);
        break;
      }
      tries++;
    }
    if (tries >= 120) {
      console.warn('Test polling timeout after 120 attempts');
      statusEl.textContent = "timeout - check manually";
    }
  } catch (err) {
    statusEl.textContent = "test failed";
    console.error('Test error:', err);
  }
};

if (typeof marked !== "undefined") {
  marked.setOptions({
    gfm: true,
    breaks: true,
    smartLists: true,
    smartypants: false
  });
} else {
  console.warn("marked.js not loaded; problem statements may render incorrectly.");
}

const parseMarkdown = (text) => {
  if (typeof marked !== "undefined" && typeof marked.parse === "function") {
    return marked.parse(text);
  }
  console.warn("Falling back to basic Markdown parser.");
  return text
    .split(/\n{2,}/)
    .map(block => `<p>${escapeHtml(block)}</p>`)
    .join("");
};

// Initialize and load problems
// In online mode, don't auto-select - wait for match-started event
const shouldAutoSelect = !isOnlineMode;
console.log('Initializing problems, autoSelect:', shouldAutoSelect, 'isOnlineMode:', isOnlineMode);
loadProblemOptions(shouldAutoSelect).catch(err => {
  console.error('Failed to load problems:', err);
});

function renderRunResult(run) {
  if (!run) {
    runSummary.textContent = "No results yet.";
    rlog.textContent = "";
    updateStatusBadge();
    return;
  }
  const overallClass = run.ok ? "pass" : "fail";
  const overallText = run.ok ? "All tests passed." : "Some tests failed.";
  const tests = Array.isArray(run.tests) ? run.tests : [];
  const testsHtml = tests.map((test, idx) => {
    const passed = !!test.passed;
    const cls = passed ? "pass" : "fail";
    const verdict = passed ? "pass" : (test.verdict || "fail");
    const elapsed = formatMetric(test.elapsed_seconds, test.elapsed);
    const memory = formatMemory(test.max_rss_kb);
    return `<li class="${cls}">Test case ${test.test || idx + 1}: ${verdict}<span>${elapsed}${elapsed && memory ? " · " : ""}${memory}</span></li>`;
  }).join("");

  const perf = run.performance || {};
  const metrics = [];
  const maxElapsed = formatDuration(perf.max_elapsed_seconds);
  if (maxElapsed) metrics.push(`Max time: ${maxElapsed}`);
  const avgElapsed = formatDuration(perf.avg_elapsed_seconds);
  if (avgElapsed) metrics.push(`Avg time: ${avgElapsed}`);
  const maxMem = formatMemory(perf.max_memory_kb);
  if (maxMem) metrics.push(`Max RAM: ${maxMem}`);

  runSummary.innerHTML = `
    <div class="overall ${overallClass}">${overallText}</div>
    ${testsHtml ? `<ul class="run-tests">${testsHtml}</ul>` : "<em>No test summary.</em>"}
    ${metrics.length ? `<div class="run-metrics">${metrics.map(m => `<div>${m}</div>`).join("")}</div>` : ""}
  `;
  rlog.textContent = JSON.stringify(run, null, 2);
  if (currentProblemId) {
    const statusValue = run.ok ? "completed" : "in-progress";
    setProblemStatus(currentProblemId, statusValue);
    updateStatusBadge();
  }
}

function renderStatementContent(markdown) {
  statementBody.innerHTML = "";
  if (!markdown) {
    statementBody.textContent = "No statement available for this problem.";
    return { title: null, hasSample: false };
  }
  const temp = document.createElement("div");
  temp.innerHTML = parseMarkdown(markdown);

  let docTitle = null;
  const sections = [];
  let current = null;
  let hasSampleSection = false;

  const ensureSection = () => {
    if (!current) {
      current = { heading: "Problem Description", nodes: [] };
      sections.push(current);
    }
  };

  Array.from(temp.children).forEach((node) => {
    if (!(node instanceof HTMLElement)) return;
    const tag = node.tagName.toUpperCase();
    if (tag === "H1") {
      docTitle = node.textContent.trim();
      return;
    }
    if (/^H[2-6]$/.test(tag)) {
      const heading = node.textContent.trim();
      current = { heading, nodes: [] };
      sections.push(current);
      return;
    }
    const textContent = node.textContent.trim();
    if (tag === "P" && !textContent) return;
    if (tag === "P" && /use problem_id/i.test(textContent)) return;
    ensureSection();
    current.nodes.push(node);
  });

  sections.forEach((section) => {
    if (!section.nodes.length) return;
    const block = document.createElement("div");
    block.className = "statement-section";
    const heading = section.heading;
    const isDefault = heading === "Problem Description";
    const headingLower = (heading || "").toLowerCase();
    const isSampleInput = headingLower.includes("sample input");
    const isSampleOutput = headingLower.includes("sample output");
    const isSample = isSampleInput || isSampleOutput;
    if (!isDefault && heading) {
      const h3 = document.createElement("h3");
      h3.textContent = heading;
      block.appendChild(h3);
    }
    section.nodes.forEach((node) => {
      if (isSample && node.tagName.toUpperCase() === "PRE") {
        hasSampleSection = true;
        const box = document.createElement("div");
        box.className = "sample-box";
        const code = document.createElement("code");
        code.textContent = node.textContent.trimEnd();
        box.appendChild(code);
        block.appendChild(box);
      } else {
        block.appendChild(node);
      }
    });
    statementBody.appendChild(block);
  });

  if (!statementBody.childElementCount) {
    statementBody.textContent = "No statement available for this problem.";
  }

  return { title: docTitle, hasSample: hasSampleSection };
}

function appendSampleSections(samples) {
  samples.forEach((sample, index) => {
    const section = document.createElement("div");
    section.className = "statement-section";

    const heading = document.createElement("h3");
    const label = sample.label || (samples.length > 1 ? `Sample ${index + 1}` : "Sample");
    heading.textContent = label;
    section.appendChild(heading);

    if (typeof sample.input === "string") {
      section.appendChild(createSampleBlock("Input", sample.input));
    }
    if (typeof sample.output === "string") {
      section.appendChild(createSampleBlock("Output", sample.output));
    }

    statementBody.appendChild(section);
  });
}

function createSampleBlock(title, content) {
  const wrapper = document.createElement("div");
  wrapper.className = "sample-block";
  const caption = document.createElement("span");
  caption.className = "sample-caption";
  caption.textContent = title;
  wrapper.appendChild(caption);

  const box = document.createElement("div");
  box.className = "sample-box";
  const code = document.createElement("code");
  code.textContent = (content || "").trimEnd();
  box.appendChild(code);
  wrapper.appendChild(box);
  return wrapper;
}

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function formatTimeLimit(ms) {
  if (ms === null || ms === undefined) return "";
  const num = Number(ms);
  if (!Number.isFinite(num) || num <= 0) return "";
  if (num >= 1000) {
    const seconds = num / 1000;
    const formatted = seconds >= 10 ? seconds.toFixed(1) : seconds.toFixed(2);
    return `${formatted.replace(/\.0+$/, "").replace(/\.([1-9])0$/, ".$1")} s`;
  }
  return `${Math.round(num)} ms`;
}

function formatDuration(seconds) {
  if (seconds === null || seconds === undefined) return "";
  const num = Number(seconds);
  if (!Number.isFinite(num)) return "";
  if (num >= 1) {
    return `${num.toFixed(2).replace(/\.0+$/, "").replace(/\.([1-9])0$/, ".$1")} s`;
  }
  const ms = num * 1000;
  if (ms >= 1) {
    return `${ms.toFixed(ms >= 10 ? 1 : 3).replace(/\.0+$/, "").replace(/\.([1-9])0$/, ".$1")} ms`;
  }
  return `${(ms).toFixed(3)} ms`;
}

function formatMetric(seconds, fallback) {
  const label = formatDuration(seconds);
  if (label) return label;
  if (fallback) return fallback;
  return "";
}

function formatMemory(kb) {
  if (kb === null || kb === undefined) return "";
  const num = Number(kb);
  if (!Number.isFinite(num) || num <= 0) return "";
  if (num >= 1024 * 5) {
    const mb = num / 1024;
    return `${mb.toFixed(mb >= 10 ? 1 : 2).replace(/\.0+$/, "").replace(/\.([1-9])0$/, ".$1")} MB`;
  }
  return `${num} KB`;
}

// ===== SOCKET.IO REAL-TIME CODE SPECTATING =====
const socketClient = SocketClient.getInstance();
const codeTextarea = document.getElementById('code');
const spectatorToggle = document.getElementById('spectatorToggle');
const spectatorModal = document.getElementById('spectatorModal');
const spectatorClose = document.getElementById('spectatorClose');
const opponentCodeTextarea = document.getElementById('opponentCode');
const spectatorStatus = document.getElementById('spectatorStatus');

let currentRoomCode = null;
let spectatorEnabled = false;
let codeChangeTimeout = null;

// Get room code from URL query parameter
function getRoomCodeFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('room');
}

// Get username from URL
function getUsernameFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('username') || 'Player';
}

// Get role from URL
function getRoleFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('role') || 'player';
}

// Initialize Socket.IO connection
async function initializeSocket() {
  currentRoomCode = getRoomCodeFromURL();
  const username = getUsernameFromURL();
  const role = getRoleFromURL();
  
  if (!currentRoomCode) {
    console.log('No room code found in URL - running in solo mode');
    return;
  }

  try {
    await socketClient.connect();
    
    // Register all event listeners BEFORE joining room
    socketClient.on('settings-updated', (data) => {
      matchSettings = data.settings;
      spectatorEnabled = data.settings.spectator;
      if (matchSettings && matchSettings.language) {
        enforceHostLanguage(matchSettings.language);
      }
      
      if (spectatorEnabled) {
        spectatorToggle.style.display = 'block';
      } else {
        spectatorToggle.style.display = 'none';
        spectatorModal.classList.remove('show');
      }
    });
    
    socketClient.on('opponent-code-update', (data) => {
      if (spectatorEnabled && data.code !== undefined) {
        opponentCodeTextarea.value = data.code;
        
        if (data.code.trim().length > 0) {
          spectatorStatus.textContent = `Opponent coding: ${data.code.length} characters`;
        } else {
          spectatorStatus.textContent = 'Waiting for opponent';
        }
      }
    });
    
    socketClient.on('opponent-submitted', (data) => {
      if (spectatorEnabled) {
        spectatorStatus.textContent = `${data.username || 'Opponent'} submitted code`;
        spectatorStatus.style.background = 'rgba(255, 179, 122, 0.2)';
        spectatorStatus.style.borderColor = '#ffb37a';
        spectatorStatus.style.color = '#ffb37a';
      }
    });
    
    socketClient.on('match-result', (data) => {
      console.log('Match result received:', data);
      showWinnerModal(data);
    });
    
    socketClient.on('match-timeout', (data) => {
      console.warn('Match timeout:', data);
      alert('Results taking too long. Check submissions manually.');
    });
    
    socketClient.on('match-started', (data) => {
      console.log('Match started event received:', data);
      
      // Update match settings
      if (data.settings) {
        matchSettings = data.settings;
        
        // Enforce host's language selection
        if (matchSettings.language) {
          enforceHostLanguage(matchSettings.language);
        }
        
        // Load the problem selected by the server
        if (data.problemId) {
          console.log('Loading problem selected by server:', data.problemId);
          
          // Update UI and load the problem
          currentProblemId = data.problemId;
          pidInput.value = currentProblemId;
          pidInput.disabled = true;
          pidInput.title = "Problem locked for this match";
          loadStatement(currentProblemId);
        }
      }
    });
    
    socketClient.on('room-joined', (data) => {
      console.log('room-joined event received:', data);
      if (data.roomState && data.roomState.settings) {
        matchSettings = data.roomState.settings;
        console.log('Room settings:', matchSettings);
        
        if (matchSettings.language) {
          enforceHostLanguage(matchSettings.language);
        }
        
        // If room has a problem already selected (match already started), load it
        if (matchSettings.problemId) {
          console.log('Room has problem already selected:', matchSettings.problemId);
          currentProblemId = matchSettings.problemId;
          pidInput.value = currentProblemId;
          pidInput.disabled = true;
          pidInput.title = "Problem locked for this match";
          loadStatement(currentProblemId);
        } else {
          console.log('Room has no problem yet - waiting for match to start');
        }
      }
    });
    
    console.log(`Joining room ${currentRoomCode} as ${username} (${role})`);
    await socketClient.joinRoom(currentRoomCode, username, role);
    
    console.log('Socket.IO initialized for room:', currentRoomCode);
  } catch (error) {
    console.error('Failed to initialize socket:', error);
  }
}

function onCodeChange() {
  if (!currentRoomCode || !spectatorEnabled) return;
  
  if (codeChangeTimeout) {
    clearTimeout(codeChangeTimeout);
  }
  
  codeChangeTimeout = setTimeout(() => {
    const code = codeTextarea.value;
    socketClient.sendCodeChange(currentRoomCode, code);
  }, 500);
}

spectatorToggle.addEventListener('click', () => {
  spectatorModal.classList.toggle('show');
  spectatorToggle.classList.toggle('active');
  
  if (spectatorModal.classList.contains('show')) {
    spectatorToggle.textContent = 'Hide Opponent';
  } else {
    spectatorToggle.textContent = 'View Opponent Code';
  }
});

spectatorClose.addEventListener('click', () => {
  spectatorModal.classList.remove('show');
  spectatorToggle.classList.remove('active');
  spectatorToggle.textContent = 'View Opponent Code';
});

spectatorModal.addEventListener('click', (e) => {
  if (e.target === spectatorModal) {
    spectatorModal.classList.remove('show');
    spectatorToggle.classList.remove('active');
    spectatorToggle.textContent = 'View Opponent Code';
  }
});

codeTextarea.addEventListener('input', onCodeChange);

initializeSocket();

const winnerModal = document.getElementById('winnerModal');
const winnerEmoji = document.getElementById('winnerEmoji');
const winnerTitle = document.getElementById('winnerTitle');
const winnerSubtitle = document.getElementById('winnerSubtitle');
const winnerPlayers = document.getElementById('winnerPlayers');
const continueBtn = document.getElementById('continueBtn');
const backToRoomBtn = document.getElementById('backToRoomBtn');

function showWinnerModal(data) {
  const comparison = data.comparison || {};
  const players = data.players || {};
  const matchInfo = data.match || {};
  const roundWinner = data.winner;
  const roundNumber = data.round || matchInfo.roundsPlayed || 1;
  const totalRounds = matchInfo.totalRounds || matchInfo.scheduledRounds || 1;
  const matchStatus = matchInfo.status || 'in_progress';
  const overallWinner = matchInfo.overallWinner || null;
  const scores = matchInfo.scores || {};
  const needsTieBreak = !!matchInfo.needsTieBreak;
  const isMatchComplete = matchStatus === 'completed';
  const sortedScores = Object.entries(scores)
    .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]));
  const scoreSummary = sortedScores
    .map(([name, wins]) => `${name}: ${wins}`)
    .join(' · ');

  backToRoomBtn.textContent = 'Main Menu';

  if (isMatchComplete) {
    if (overallWinner && overallWinner !== 'TIE') {
      winnerEmoji.textContent = '*';
      winnerTitle.textContent = `${overallWinner} wins the match!`;
      winnerSubtitle.textContent = scoreSummary ? `Final score · ${scoreSummary}` : 'Victory secured.';
    } else {
      winnerEmoji.textContent = '=';
      winnerTitle.textContent = 'Match ends in a draw';
      winnerSubtitle.textContent = scoreSummary ? `After ${totalRounds} rounds · ${scoreSummary}` : 'Both sides remain tied.';
    }
  } else if (needsTieBreak) {
    winnerEmoji.textContent = '!';
    winnerTitle.textContent = 'Tie-break required';
    winnerSubtitle.textContent = 'Scheduled rounds ended in a tie. One extra round will decide the winner.';
  } else if (roundWinner === 'TIE') {
    winnerEmoji.textContent = '=';
    winnerTitle.textContent = `Round ${roundNumber} ends in a tie`;
    winnerSubtitle.textContent = 'No advantage gained this round.';
  } else {
    winnerEmoji.textContent = '*';
    winnerTitle.textContent = `${roundWinner} wins Round ${roundNumber}`;
    let reasonText = 'wins the round';
    if (comparison.reason === 'accuracy') {
      reasonText = 'by higher accuracy';
    } else if (comparison.reason === 'time') {
      reasonText = 'by faster execution time';
    } else if (comparison.reason === 'memory') {
      reasonText = 'by lower memory usage';
    }
    winnerSubtitle.textContent = `${reasonText}.`;
  }
  
  winnerPlayers.innerHTML = '';
  
  Object.entries(players).forEach(([playerName, playerData]) => {
    const perf = playerData.performance;
    const statusLabel = String(playerData.status || 'unknown').replace(/_/g, ' ');
    const accuracyValue = Number(perf.accuracy ?? 0);
    const accuracyPercent = Number.isFinite(accuracyValue) ? accuracyValue : 0;
    const timeSeconds =
      perf.median_elapsed_seconds ??
      perf.avg_elapsed_seconds ??
      perf.max_elapsed_seconds ??
      null;
    const memoryKb =
      perf.median_memory_kb ??
      perf.avg_memory_kb ??
      perf.max_memory_kb ??
      null;
    const roundWinCount = scores[playerName] ?? 0;
    const timeLabel = Number.isFinite(timeSeconds) ? `${(timeSeconds * 1000).toFixed(2)}ms` : 'N/A';
    const memoryLabel = Number.isFinite(memoryKb) ? `${(memoryKb / 1024).toFixed(2)}MB` : 'N/A';
    
    const playerCard = document.createElement('div');
    const isRoundWinner = roundWinner === playerName && roundWinner !== 'TIE';
    const isOverallChampion = overallWinner && overallWinner === playerName;
    playerCard.className = `winner-player ${(isRoundWinner || isOverallChampion) ? 'winner' : ''}`;
    
    const nameDiv = document.createElement('div');
    nameDiv.className = 'winner-player-name';
    nameDiv.textContent = `${playerName}${isRoundWinner || isOverallChampion ? ' [W]' : ''}`;
    
    const metricsDiv = document.createElement('div');
    metricsDiv.className = 'winner-player-metrics';
    
    metricsDiv.innerHTML = `
      <div>Status: ${statusLabel}</div>
      <div>Match wins: ${roundWinCount}</div>
      <div>Accuracy: ${accuracyPercent.toFixed(1)}%</div>
      <div>Time: ${timeLabel}</div>
      <div>Memory: ${memoryLabel}</div>
    `;
    
    playerCard.appendChild(nameDiv);
    playerCard.appendChild(metricsDiv);
    winnerPlayers.appendChild(playerCard);
  });

  if (sortedScores.length) {
    const scoreboardDiv = document.createElement('div');
    scoreboardDiv.className = 'winner-scoreboard';

    const scoreboardTitle = document.createElement('div');
    scoreboardTitle.className = 'winner-scoreboard-title';
    scoreboardTitle.textContent = 'Match Scoreboard';
    scoreboardDiv.appendChild(scoreboardTitle);

    sortedScores.forEach(([name, wins]) => {
      const row = document.createElement('div');
      row.className = 'winner-scoreboard-row';

      const nameSpan = document.createElement('span');
      nameSpan.textContent = name;

      const winsSpan = document.createElement('span');
      winsSpan.textContent = `${wins} win${wins === 1 ? '' : 's'}`;

      row.appendChild(nameSpan);
      row.appendChild(winsSpan);
      scoreboardDiv.appendChild(row);
    });

    winnerPlayers.appendChild(scoreboardDiv);
  }
  
  if (isMatchComplete) {
    continueBtn.style.display = 'none';
  } else {
    continueBtn.style.display = 'block';
    if (needsTieBreak) {
      continueBtn.textContent = 'Play Tie-break Round';
    } else {
      continueBtn.textContent = `Next Round (${Math.min(roundNumber + 1, totalRounds)})`;
    }
  }
  
  winnerModal.classList.add('show');
}

continueBtn.addEventListener('click', () => {
  winnerModal.classList.remove('show');
  statusEl.textContent = 'idle';
  clog.textContent = '';
  renderRunResult(null);
});

backToRoomBtn.addEventListener('click', () => {
  window.location.href = '/mainmenu.html';
});

</script>
</body>
</html>
